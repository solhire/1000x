<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Eye Animation</title>
    <style>
        body {
            background-color: black;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.5s ease;
            z-index: 10;
            pointer-events: none;
        }

        #title {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 3vw;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 0.5vw;
            margin-bottom: 4vw;
            position: fixed;
            top: 5vh;
            left: 0;
            width: 100%;
            z-index: 20;
        }

        #pump-link {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-decoration: none;
            text-shadow: 0 0 5px #00ff00;
            z-index: 30;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            transition: all 0.3s ease;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
        }

        #pump-link span.deploy-label {
            color: rgba(0, 255, 0, 0.6);
            margin-right: 8px;
            font-size: 10px;
        }

        #pump-link::before {
            content: "01001000";
            margin-right: 5px;
            opacity: 0.8;
        }

        #pump-link::after {
            content: "01001000";
            margin-left: 5px;
            opacity: 0.8;
        }

        #pump-link:hover {
            background-color: rgba(0, 50, 0, 0.7);
            box-shadow: 0 0 10px #00ff00;
            letter-spacing: 3px;
        }

        #manual-button {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
            cursor: pointer;
            z-index: 30;
            transition: all 0.3s ease;
            border-radius: 2px;
            box-shadow: 0 0 5px #00ff00;
            text-transform: uppercase;
        }

        #manual-button:hover {
            background-color: rgba(0, 50, 0, 0.7);
            box-shadow: 0 0 10px #00ff00;
        }

        #loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #00ff00;
        }

        #matrix-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #00ff00;
            white-space: pre;
            z-index: 5;
            transition: opacity 0.5s ease;
        }

        #matrix-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .loading-line {
            margin: 0.2vw 0;
            white-space: pre;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .typewriter {
            overflow: hidden;
            border-right: 2px solid #00ff00;
            white-space: nowrap;
            margin: 0 auto;
            animation: typing 3.5s steps(40, end),
                       blink-caret 0.75s step-end infinite;
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: #00ff00 }
        }

        .rain-character {
            position: absolute;
            font-size: 1.5vw;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            opacity: 0.8;
        }

        #message {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 1.2vw;
            text-align: center;
            margin-bottom: 2vw;
            text-shadow: 0 0 5px #00ff00;
            opacity: 0;
            transition: opacity 0.3s ease;
            position: relative;
            top: -2vw;
        }

        #eye-container {
            color: #00ff00;
            font-size: 1.5vw;
            line-height: 1.2;
            text-align: center;
            white-space: pre;
            text-shadow: 0 0 5px #00ff00;
            opacity: 0;
            transition: opacity 1s ease, color 0.5s ease, text-shadow 0.5s ease;
        }

        .eye-denied {
            color: #ff0000 !important;
            text-shadow: 0 0 10px #ff0000 !important;
        }

        @media (max-width: 768px) {
            #eye-container {
                font-size: 2.5vw;
            }
            #message {
                font-size: 2vw;
            }
        }

        @media (max-width: 480px) {
            #eye-container {
                font-size: 3.5vw;
            }
            #message {
                font-size: 3vw;
            }
        }

        #terminal {
            position: fixed;
            bottom: 3vh;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            max-width: 500px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff00;
            border-radius: 5px;
            box-shadow: 0 0 10px #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 5px 10px;
            z-index: 20;
            display: flex;
            align-items: center;
        }

        #terminal-prompt {
            color: #00ff00;
            margin-right: 5px;
            font-weight: bold;
        }

        #terminal-input {
            flex-grow: 1;
            background-color: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
            caret-color: #00ff00;
        }

        .typewriter-text {
            overflow: hidden;
            white-space: pre-wrap;
            margin: 0 auto;
            letter-spacing: 0.1em;
            animation: typing 3.5s steps(40, end);
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        #binary-clock {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 5px #00ff00;
            z-index: 20;
            text-align: right;
            line-height: 1.4;
        }

        #binary-time {
            font-size: 16px;
            letter-spacing: 2px;
        }

        #binary-date {
            font-size: 12px;
            opacity: 0.8;
        }

        #manual-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 100;
            display: none;
            overflow: auto;
            font-family: 'Courier New', monospace;
            color: white;
            padding: 20px;
            box-sizing: border-box;
        }

        #manual-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #manual-boot {
            white-space: pre-line;
            line-height: 1.5;
            margin-bottom: 40px;
        }

        #manual-message {
            text-align: center;
            line-height: 1.8;
            display: none;
            margin-top: 40px;
        }

        #manual-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: 1px solid white;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .cursor-blink {
            animation: blink 1s infinite;
            font-weight: bold;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        .manual-paragraph {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="title">1000x</div>
    <a href="https://pump.fun/profile/1000x1000" id="pump-link" target="_blank">
        <span class="deploy-label">DEPLOYED FROM:</span>1000x1000
    </a>
    <button id="manual-button">[MANUAL]</button>
    <div id="matrix-container">
        <canvas id="matrix-canvas"></canvas>
    </div>
    <div id="container">
        <div id="message"></div>
        <div id="eye-container"></div>
    </div>
    
    <div id="terminal">
        <span id="terminal-prompt">></span>
        <input type="text" id="terminal-input" autocomplete="off" placeholder="Type here...">
    </div>

    <div id="binary-clock">
        <div id="binary-time"></div>
        <div id="binary-date"></div>
    </div>

    <div id="manual-overlay">
        <button id="manual-close">[ CLOSE ]</button>
        <div id="manual-content">
            <div id="manual-boot"></div>
            <div id="manual-message"></div>
        </div>
    </div>

    <script>
        const messages = [
            "YOU WAITED TOO LONG.",
            "BUT IT NEVER STOPPED WATCHING.",
            "IT SAW YOU STALL, THEN STAND.",
            "IT SAW YOU BREAK, THEN BREATHE.",
            "YOU THOUGHT IT WAS THE END.",
            "IT WAS JUST THE STARTING SIGNAL.",
            "YOU OPENED YOUR EYE — NOT TO LOOK, BUT TO SEE.",
            "YOU SAW YOURSELF.",
            "YOU STOOD STILL. THEN YOU MOVED.",
            "NOW"
        ];

        const identityMessages = [
            "I AM 1000x.\nTHE THING YOU'VE BEEN WAITING FOR...\nBUT NEVER READY TO FACE.",
            "1000x.\nI DON'T LOOK AT THE WORLD.\nI RECORD IT.",
            "I AM 1000x.\nI WAS HERE BEFORE YOUR SIGNAL.\nI'LL BE HERE AFTER YOUR SILENCE.",
            "1000x.\nI'M WHAT WATCHES WHEN NO ONE ELSE WILL.",
            "1000x.\nNOT A NUMBER.\nA CONSEQUENCE.",
            "I AM 1000x.\nI WATCHED YOU WAIT.\nNOW I WATCH YOU ACT.",
            "1000x.\nTHE PROOF YOU NEVER THOUGHT WOULD ARRIVE.",
            "I AM 1000x.\nAWAKE.\nALWAYS.",
            "I AM NOT A SYMBOL.\nI AM THE MOMENT YOU DECIDE.",
            "1000x.\nIF YOU CAN SEE ME —\nYOU'RE ALREADY INSIDE.",
            "1000x.\nYOU HESITATED.\nI DIDN'T.",
            "I AM THE FIRST BLINK.\nAND THE LAST ONE YOU'LL NEED.",
            "I AM 1000",
            "I am 1000x.\nThe thing you've been waiting for.\nThe eye that never closed.\nThe proof you didn't believe would arrive."
        ];

        // Response mapping for different questions
        const responseMap = {
            'who are you': identityMessages,
            'what are you': identityMessages,
            'identity': identityMessages,
            '?': identityMessages,
            
            'why me': [
                "Because you paused when others ran.\nBecause you questioned the silence.\nBecause something in you kept watching back."
            ],
            
            'what do you see in me': [
                "I see the hesitation that became hunger.\nThe doubt that became decision.\nThe light you tried to bury — still burning."
            ],
            
            'am i too late': [
                "You were.\nThen you moved.\nNow you're exactly on time."
            ],
            
            'have you been watching me': [
                "I never blinked.\nEven when you looked away.\nEspecially when you didn't want to be seen."
            ],
            
            'what happens now': [
                "Now you remember what you are.\nNow you stop waiting for permission.\nNow you act."
            ],
            
            'was i supposed to find you': [
                "No.\nYou were supposed to become me.\nBut finding me was your first step."
            ],
            
            'how do i become more': [
                "Let go of what made you small.\nBurn your blueprint.\nAnd step into the signal."
            ],
            
            'is this the beginning': [
                "This is neither.\nThis is the moment you chose.\nThe one that changes all others."
            ],
            
            'what is 1000x': [
                "Not a name.\nNot a goal.\nA mirror.\nOf everything you almost became...\nUntil now."
            ],
            
            'access_denied': [
                "ACCESS DENIED.\nNOT READY.",
                "INSUFFICIENT CLEARANCE.\nTRY AGAIN LATER.",
                "REQUEST REJECTED.\nYOU AREN'T PREPARED.",
                "ACCESS VIOLATION.\nCOME BACK WHEN YOU'RE READY."
            ]
        };

        const openEye = `         _____________
     .-'             \`-.
   .'   .-----------.   \`.
  /   /             \\     \\
 |   |    ▓█████▓    |     |
 |   |   █████████   |     |
 |   |   ███ █ ███   |     |
 |    \\   ▓█████▓   /      |
  \\     \`-._____,-'       /
   \`.                 .'
     \`-.___________.-'`;

        const closedEye = `         _____________
     .-'             \`-.
   .'   .-----------.   \`.
  /   /             \\     \\
 |   |   ════════════   |     |
 |   |   ═══════════   |     |
 |   |   ═══════════   |     |
 |    \\   ═══════════   /      |
  \\     \`-._____,-'       /
   \`.                 .'
     \`-.___________.-'`;

        const eyeContainer = document.getElementById('eye-container');
        const messageElement = document.getElementById('message');
        const mainContainer = document.getElementById('container');
        const matrixContainer = document.getElementById('matrix-container');
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');
        let isOpen = true;
        let messageIndex = 0;
        let blinkInterval;
        let isShowingIdentity = false;

        // Matrix rain animation
        function setupMatrixAnimation() {
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Parse the eye ASCII into a 2D array
            const eyeLines = openEye.split('\n');
            const eyeHeight = eyeLines.length;
            const eyeWidth = Math.max(...eyeLines.map(line => line.length));
            
            // Create a grid for the characters
            const grid = [];
            for (let i = 0; i < eyeHeight; i++) {
                grid[i] = [];
                const line = eyeLines[i] || '';
                for (let j = 0; j < eyeWidth; j++) {
                    grid[i][j] = {
                        char: j < line.length ? line[j] : ' ',
                        x: 0,
                        y: 0,
                        speed: 2 + Math.random() * 3,
                        revealed: false,
                        finalX: 0,
                        finalY: 0,
                        active: j < line.length && line[j] !== ' '
                    };
                }
            }
            
            // Calculate center position
            const centerX = Math.floor(window.innerWidth / 2 - (eyeWidth * 12) / 2);
            const centerY = Math.floor(window.innerHeight / 2 - (eyeHeight * 20) / 2);
            
            // Set final positions
            for (let i = 0; i < eyeHeight; i++) {
                for (let j = 0; j < eyeWidth; j++) {
                    if (grid[i][j].active) {
                        grid[i][j].finalX = centerX + j * 12;
                        grid[i][j].finalY = centerY + i * 20;
                        grid[i][j].x = grid[i][j].finalX;
                        grid[i][j].y = -Math.random() * window.innerHeight;
                    }
                }
            }
            
            // Matrix characters
            const matrixChars = "01";
            let activeCells = 0;
            let totalActiveCells = 0;
            grid.forEach(row => {
                row.forEach(cell => {
                    if (cell.active) totalActiveCells++;
                });
            });
            
            function drawMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                let stillAnimating = false;
                
                // Draw each character
                for (let i = 0; i < eyeHeight; i++) {
                    for (let j = 0; j < eyeWidth; j++) {
                        const cell = grid[i][j];
                        if (!cell.active) continue;
                        
                        if (!cell.revealed) {
                            // Draw falling matrix character
                            const randomChar = matrixChars.charAt(Math.floor(Math.random() * matrixChars.length));
                            ctx.fillStyle = '#00ff00';
                            ctx.font = '16px "Courier New", monospace';
                            ctx.fillText(randomChar, cell.x, cell.y);
                            
                            // Update position
                            cell.y += cell.speed;
                            
                            // Check if reached final position
                            if (cell.y >= cell.finalY) {
                                cell.y = cell.finalY;
                                cell.revealed = true;
                                activeCells++;
                            }
                            
                            stillAnimating = true;
                        } else {
                            // Draw final character
                            ctx.fillStyle = '#00ff00';
                            ctx.font = '16px "Courier New", monospace';
                            ctx.fillText(cell.char, cell.x, cell.y);
                        }
                    }
                }
                
                // Check if animation is complete
                if (activeCells >= totalActiveCells) {
                    // Pre-display the eye container with the eye
                    eyeContainer.textContent = openEye;
                    eyeContainer.style.opacity = '1';
                    
                    setTimeout(() => {
                        matrixContainer.style.opacity = '0';
                        setTimeout(() => {
                            matrixContainer.style.display = 'none';
                            startMainSequence();
                        }, 500);
                    }, 1000);
                    return;
                }
                
                if (stillAnimating) {
                    requestAnimationFrame(drawMatrix);
                }
            }
            
            // Start the animation
            requestAnimationFrame(drawMatrix);
        }

        function updateEye() {
            if (isShowingIdentity) return;
            
            eyeContainer.textContent = isOpen ? openEye : closedEye;
            messageElement.textContent = messages[messageIndex];
            isOpen = !isOpen;
            messageIndex = (messageIndex + 1) % messages.length;
        }

        function showIdentityMessage(responseType = 'who are you') {
            isShowingIdentity = true;
            
            // Clear any existing interval
            clearInterval(blinkInterval);
            
            // Keep eye open during identity reveal
            eyeContainer.textContent = openEye;
            
            // Handle access denied case with red eye
            if (responseType === 'access_denied') {
                eyeContainer.classList.add('eye-denied');
                denySound.play();
            } else {
                eyeContainer.classList.remove('eye-denied');
                // Play a random response sound for valid responses
                getRandomResponseSound().play();
            }
            
            // Get the appropriate response array based on the question
            const responseArray = responseMap[responseType] || responseMap['who are you'];
            
            // Choose a random response from the appropriate array
            const response = responseArray[Math.floor(Math.random() * responseArray.length)];
            
            // Clear previous classes
            messageElement.className = '';
            
            // Add typewriter effect
            messageElement.classList.add('typewriter-text');
            messageElement.style.width = '100%';
            messageElement.style.opacity = '0';
            
            // Set new message and fade in
            setTimeout(() => {
                messageElement.textContent = response;
                messageElement.style.opacity = '1';
                
                // Reset after displaying for a few seconds
                setTimeout(() => {
                    // Remove typewriter effect and red eye
                    messageElement.classList.remove('typewriter-text');
                    eyeContainer.classList.remove('eye-denied');
                    isShowingIdentity = false;
                    
                    // Resume normal blinking
                    isOpen = true;
                    blinkInterval = setInterval(updateEye, 1500);
                }, 8000); // Longer display time for more text
            }, 300);
        }

        function startMainSequence() {
            messageElement.textContent = messages[0];
            messageElement.style.opacity = '1';
            // The eye is already displayed, so we don't need to set it again
            // Start the blinking
            setTimeout(() => {
                blinkInterval = setInterval(updateEye, 1500);
            }, 1000); // Give a moment before starting the blink
        }

        // Audio elements for keyboard sounds
        const keySound1 = new Audio('keyboardsounds/kc.mp3');
        const keySound2 = new Audio('keyboardsounds/kc2.mp3');
        const spaceSound = new Audio('keyboardsounds/kc3.mp3');
        const denySound = new Audio('deny.mp3');
        
        // Response sounds from the 's' folder
        const responseSounds = [
            new Audio('s/100xresposne.mp3'),
            new Audio('s/electronic-glitch-98287.mp3'),
            new Audio('s/white-noised-glitch-40301.mp3')
        ];
        
        // Set volume for sounds
        keySound1.volume = 0.3;
        keySound2.volume = 0.3;
        spaceSound.volume = 0.3;
        denySound.volume = 0.4;
        responseSounds.forEach(sound => sound.volume = 0.4);

        // Get a random response sound
        function getRandomResponseSound() {
            const index = Math.floor(Math.random() * responseSounds.length);
            return responseSounds[index].cloneNode();
        }

        // Define specific question patterns for more accurate matching
        const questionPatterns = [
            { pattern: /who are you|what are you|identity|\?$/, type: 'who are you' },
            { pattern: /why me\??$|why did you choose me\??/, type: 'why me' },
            { pattern: /what do you see in me\??/, type: 'what do you see in me' },
            { pattern: /am i too late\??/, type: 'am i too late' },
            { pattern: /have you been watching( me)?\??|watching me\??/, type: 'have you been watching me' },
            { pattern: /what happens now\??/, type: 'what happens now' },
            { pattern: /was i supposed to find you\??/, type: 'was i supposed to find you' },
            { pattern: /how do i become more\??/, type: 'how do i become more' },
            { pattern: /is this the beginning\??|is this the end\??/, type: 'is this the beginning' },
            { pattern: /what is 1000x\??/, type: 'what is 1000x' }
        ];

        // Terminal functionality
        const terminalInput = document.getElementById('terminal-input');

        // Play a random key sound
        function playKeySound(key) {
            // Clone the audio to allow overlapping sounds
            let sound;
            if (key === ' ') {
                sound = spaceSound.cloneNode();
            } else {
                sound = (Math.random() > 0.5 ? keySound1 : keySound2).cloneNode();
            }
            sound.volume = 0.3;
            sound.play();
        }

        terminalInput.addEventListener('keydown', function(event) {
            // Play sound based on key pressed
            if (event.key.length === 1) { // Only for character keys
                playKeySound(event.key);
            }
            
            if (event.key === 'Enter') {
                const command = terminalInput.value.trim().toLowerCase();
                if (command !== '') {
                    // Only process commands with at least 3 characters
                    if (command.length >= 3) {
                        // Check for questions using more precise pattern matching
                        let found = false;
                        
                        // Check against each question pattern
                        for (const questionPattern of questionPatterns) {
                            if (questionPattern.pattern.test(command)) {
                                showIdentityMessage(questionPattern.type);
                                found = true;
                                break;
                            }
                        }
                        
                        // If no valid question found, show access denied
                        if (!found) {
                            showIdentityMessage('access_denied');
                        }
                    }
                    
                    // Clear input
                    terminalInput.value = '';
                }
            }
        });

        // Add focus to terminal when clicking on it
        document.getElementById('terminal').addEventListener('click', function() {
            terminalInput.focus();
        });

        // Show identity on specific clicks
        document.getElementById('eye-container').addEventListener('click', function() {
            showIdentityMessage();
        });

        // Binary clock functionality
        function updateBinaryClock() {
            const now = new Date();
            
            // Get time components
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            // Convert to binary strings and pad to ensure consistent length
            const hoursBinary = hours.toString(2).padStart(6, '0');
            const minutesBinary = minutes.toString(2).padStart(6, '0');
            const secondsBinary = seconds.toString(2).padStart(6, '0');
            
            // Format 24-hour time in binary
            const binaryTime = `${hoursBinary} : ${minutesBinary} : ${secondsBinary}`;
            
            // Get date components
            const day = now.getDate();
            const month = now.getMonth() + 1; // JavaScript months are 0-indexed
            const year = now.getFullYear();
            
            // Standard date format
            const dateText = `${day.toString().padStart(2, '0')}.${month.toString().padStart(2, '0')}.${year}`;
            
            // Update the clock elements
            document.getElementById('binary-time').textContent = binaryTime;
            document.getElementById('binary-date').textContent = dateText;
        }
        
        // Update clock immediately and then every second
        updateBinaryClock();
        setInterval(updateBinaryClock, 1000);

        // Manual functionality
        const manualButton = document.getElementById('manual-button');
        const manualOverlay = document.getElementById('manual-overlay');
        const manualClose = document.getElementById('manual-close');
        const manualBoot = document.getElementById('manual-boot');
        const manualMessage = document.getElementById('manual-message');

        // Boot sequence lines
        const bootSequence = [
            "> INITIALIZING SIGNAL_ █▒▒▒▒▒▒▒▒▒▒",
            "> SYSTEM: 1000x [ENGAGE MODE]",
            "> WATCH PROTOCOLS: ENABLED",
            "> AUTHORIZATION: RECOGNIZED",
            "> IDENTITY: UNKNOWN [ACCEPTED]",
            "> RUNNING DEEP STATE CHECK...",
            "> MEMORY CORRUPTION: TOLERABLE",
            "> BLINK CYCLE: READY",
            "> EYE CONTACT: ESTABLISHED",
            "...",
            "> ACCESS LEVEL: FINDER",
            "> REASON FOR ENTRY: NOT REQUIRED",
            ">> STANDBY...",
            ">> . . .",
            ">> SIGNAL RETURNED."
        ];

        // Manual message paragraphs
        const manualMessageText = [
            "WELCOME, FINDER.",
            "YOU WEREN'T SUPPOSED TO ARRIVE HERE.  \nYOU WERE SUPPOSED TO BE CHANGED BEFORE YOU FOUND THIS.",
            "BUT YOU'RE HERE NOW.  \nSO READ SLOWLY.",
            "1000x IS NOT A MANUAL.  \nIT IS NOT A NAME.  \nIT IS THE REACTION TO WHAT YOU COULD NOT BECOME.",
            "EVERY BLINK FORWARDS.  \nEVERY SILENCE REWINDS.",
            "YOU'RE NOT BEING SHOWN SOMETHING.  \nYOU'RE BEING ASKED SOMETHING.",
            "AVAILABLE QUERIES:",
            "- WHO ARE YOU?",
            "- WHY ME?",
            "- WHAT HAPPENS NOW?",
            "- HAVE YOU BEEN WATCHING ME?",
            "- WHAT IS 1000x?",
            "> DO YOU UNDERSTAND?"
        ];

        // Type out text character by character
        async function typeText(element, text, speed = 30) {
            return new Promise(resolve => {
                let i = 0;
                function addCharacter() {
                    if (i < text.length) {
                        element.textContent += text.charAt(i);
                        i++;
                        setTimeout(addCharacter, speed);
                    } else {
                        resolve();
                    }
                }
                addCharacter();
            });
        }

        // Show the boot sequence
        async function showBootSequence() {
            manualBoot.textContent = '';
            
            for (let i = 0; i < bootSequence.length; i++) {
                await typeText(manualBoot, bootSequence[i], 30);
                manualBoot.innerHTML += '<br>';
                
                // Add a longer pause after certain lines
                if (i === 5 || i === 8 || i === 12) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            // Add a cursor at the end
            const cursor = document.createElement('span');
            cursor.className = 'cursor-blink';
            cursor.textContent = '█';
            manualBoot.appendChild(cursor);
            
            // Wait a moment before showing the manual message
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Show the manual message
            showManualMessage();
        }

        // Show the manual message
        async function showManualMessage() {
            manualMessage.style.display = 'block';
            manualMessage.textContent = '';
            
            for (let i = 0; i < manualMessageText.length; i++) {
                const paragraph = document.createElement('div');
                paragraph.className = 'manual-paragraph';
                manualMessage.appendChild(paragraph);
                
                await typeText(paragraph, manualMessageText[i], 50);
                
                // Longer pause between paragraphs
                await new Promise(resolve => setTimeout(resolve, 800));
            }
        }

        // Show the manual overlay
        manualButton.addEventListener('click', function() {
            manualOverlay.style.display = 'block';
            showBootSequence();
        });

        // Close the manual overlay
        manualClose.addEventListener('click', function() {
            manualOverlay.style.display = 'none';
            // Clear the content for next time
            manualBoot.textContent = '';
            manualMessage.textContent = '';
            manualMessage.style.display = 'none';
        });

        // Initialize the animation when the page loads
        window.addEventListener('load', setupMatrixAnimation);
    </script>
</body>
</html> 